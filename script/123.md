#1
Now, as you can tell,
if you take a look at the official documentation,
Angular got quite a few Lifecycle Hooks.

지금, 공식 문서를 보시면 알 수 있듯이,
Angular에는 꽤 많은
라이프사이클 훅이 있습니다.

#2
quite a few methods you can add to your Component classes
to have them triggered by Angular.

컴포넌트 클래스에 추가하여
Angular가 트리거할 수 있는
많은 메서드들이 있습니다.

#3
And in that documentation at the bottom of that page,
which you also find attached to this lecture,
you also find some nice diagrams that show you the order
in which those Lifecycle Hook methods are invoked.

이 강의에 첨부된
해당 문서의 하단에서,
라이프사이클 훅 메서드들이
어떤 순서로 호출되는지 보여주는
좋은 다이어그램들을 찾을 수 있습니다.

#4
Depending on whether a Component
is rendered for the first time
or if it is just updated because some input data changed.

컴포넌트가 처음 렌더링되는지,
또는 입력 데이터가 변경되어
단순히 업데이트되는지에 따라 달라집니다.

#5
But the best way to understand this order
is to see it in Action.

하지만 이 순서를 이해하는 가장 좋은 방법은
실제로 작동하는 것을 보는 것입니다.

#6
That's why I prepared a brand new project,
and we'll get back to our main project thereafter.

그래서 새로운 프로젝트를 준비했고,
이후에 우리의 메인 프로젝트로 돌아갈 것입니다.

#7
But I prepared this project,
if you want to call it like this,
because this is a demo project
where I have one simple LifecycleComponent
where I just output some dummy text
which implements all these lifecycle interfaces,
and therefore all these lifecycle methods.

하지만 이렇게 부르고 싶다면,
이 프로젝트를 준비했는데,
이는 데모 프로젝트이며
여기에는 더미 텍스트만 출력하는
간단한 LifecycleComponent가 있고
이는 모든 라이프사이클 인터페이스를,
따라서 모든 라이프사이클 메서드를 구현합니다.

#8
And then in there I simply log to the console
because that of course is a great way of seeing
in which order these hooks are executed
and when exactly these hook methods are executed.

그리고 거기서 단순히 콘솔에 로그를 남기는데,
이는 물론 이러한 훅들이 실행되는 순서와
정확히 언제 이러한 훅 메서드들이 실행되는지
보는 좋은 방법입니다.

#9
Now, you find this project attached,
and you can of course then download it, run npm-install,
and then npm-start to start it.

이제 이 프로젝트가 첨부되어 있고,
당연히 이를 다운로드하여 npm-install을 실행하고,
그런 다음 npm-start로 시작할 수 있습니다.

#10
And if you do so, you should see this screen here.

그리고 그렇게 하면, 여기 이 화면이 보일 것입니다.

[계속 번역이 진행됩니다...]

[나머지 부분도 계속 번역하겠습니다. 글이 길어서 중간에 끊지 않고 계속 진행하고 있습니다.]

#11
And there you can toggle the LifecycleComponent visibility
so that this Component appears or disappears.

그리고 거기서 LifecycleComponent의 가시성을 전환할 수 있어서
이 컴포넌트가 나타나거나 사라지게 할 수 있습니다.

#12
And you can also change the LifecycleComponent text
so that this text down here,
and therefore mostly this number here will change
every time you click this button.

그리고 LifecycleComponent 텍스트도 변경할 수 있어서
여기 아래의 이 텍스트가,
따라서 주로 여기 이 숫자가
이 버튼을 클릭할 때마다 변경될 것입니다.

#13
And that's all happening
due to how this LifecycleComponent is built,
that it receives an input.

그리고 이 모든 것이 일어나는 것은
이 LifecycleComponent가 입력을 받도록
구축되어 있기 때문입니다.

#14
And that in the app Component,
I'm then rendering it conditionally based
on that LifecycleComponent is visible,
State property here,
which is updated whenever this first button
is clicked here in this
on toggle LifecycleComponent visibility method.

그리고 앱 컴포넌트에서,
LifecycleComponent가 보이는지에 따라
조건부로 렌더링하고 있으며,
여기 State 속성은
이 첫 번째 버튼이 클릭될 때마다
이 LifecycleComponent 가시성 전환 메서드에서
업데이트됩니다.

#15
And here I'm not using Signals,
but the behavior would be the same if I would,
so that doesn't matter here.

그리고 여기서는 Signals를 사용하지 않지만,
사용하더라도 동작은 동일할 것이므로,
여기서는 중요하지 않습니다.

#16
Now, therefore in this application,
if you open your browser developer tools,
you'll see a bunch of logs.

따라서 이 애플리케이션에서,
브라우저 개발자 도구를 열면,
많은 로그들을 보게 될 것입니다.

#17
And I'll reload this to clear my logs,
and you'll now see that if you click
on toggle LifecycleComponent visibility
to show this Component for the first time,
these are the logs that are being output.

그리고 로그를 지우기 위해 이것을 다시 로드하면,
이제 LifecycleComponent 가시성 전환을 클릭하여
이 컴포넌트를 처음으로 표시할 때,
이러한 로그들이 출력되는 것을 보게 될 것입니다.

#18
And here we also see the order
in which these different lifecycle methods are executed.

그리고 여기서 우리는 또한
이러한 다양한 라이프사이클 메서드들이
실행되는 순서를 볼 수 있습니다.

#19
It's also worth noting
that for the ngOnChanges Lifecycle Hook,
I'm also logging an argument that is received
by that Lifecycle Hook.

ngOnChanges 라이프사이클 훅에 대해
주목할 만한 점은,
해당 라이프사이클 훅이 받는
인자도 로깅하고 있다는 것입니다.

#20
This changes object which will be passed
into this lifecycle method automatically by Angular,
because all these different hooks,
of course, have different purposes.

이 변경 객체는 Angular에 의해
이 라이프사이클 메서드에 자동으로 전달되며,
이는 모든 이러한 다른 훅들이
물론 다른 목적을 가지고 있기 때문입니다.

#21
And I'll get back to those purposes in just a second.
This ngOnChanges hook, for example,
is executed by Angular whenever the input that is received,
or the inputs if it's multiple inputs,
that are received change.

이러한 목적들에 대해서는 잠시 후에 설명하겠습니다.
예를 들어, 이 ngOnChanges 훅은
받은 입력이 변경될 때마다,
또는 여러 입력이 있는 경우
그 입력들이 변경될 때마다 Angular에 의해 실행됩니다.

#22
So in this case, whenever this text input changes.
And Angular then automatically produces a changes object,
which gives you more information
about the input changes that happened.

그래서 이 경우, 이 텍스트 입력이 변경될 때마다
Angular는 자동으로 changes 객체를 생성하며,
이는 발생한 입력 변경에 대한
더 많은 정보를 제공합니다.

#23
We can see that here.
If we expand this object,
we can see that it contains one property
per Component input.

우리는 여기서 그것을 볼 수 있습니다.
이 객체를 확장하면,
컴포넌트 입력당
하나의 속성을 포함하고 있음을 볼 수 있습니다.

#24
And here I only have one input, the text input.
That's why in my case here, I only have one property here,
the text property for this text input.

그리고 여기서는 text 입력 하나만 있습니다.
그래서 이 경우에 여기 하나의 속성만 있으며,
이는 이 텍스트 입력을 위한 text 속성입니다.

#25
And if we expand that,
we get some information about that input and how it changed.
We can see the currently assigned value,
so the latest value that was received here,
which is that text that's also showing up on the screen.

그리고 이것을 확장하면,
해당 입력과 그것이 어떻게 변경되었는지에 대한 정보를 얻습니다.
현재 할당된 값을 볼 수 있는데,
이는 여기서 받은 최신 값이며,
화면에도 표시되는 텍스트입니다.

#26
We also learn whether it's the first change
that occurred here.
So if it's the initial value in the end,
and that is the case here.

또한 여기서 발생한
첫 번째 변경인지도 알 수 있습니다.
즉, 최종적으로 초기 값인지를 알 수 있으며,
여기서는 그런 경우입니다.

#27
Or if we had assigned an initial value in the Component,
we would see that previous value here as well.
또는 컴포넌트에서 초기 값을 할당했다면,
여기서 그 이전 값도 볼 수 있을 것입니다.

#28
And you get this information for all the input properties
that you do add to a Component.
그리고 컴포넌트에 추가하는
모든 입력 속성에 대해
이 정보를 얻을 수 있습니다.

#29
And whilst you might not need that information too often,
it can sometimes come in handy if you then have
some Component internal State,
so some other property in the LifecycleComponent
which you wanna change whenever the input value changes.
그리고 이 정보가 자주 필요하지는 않겠지만,
컴포넌트 내부 상태가 있을 때,
즉 입력 값이 변경될 때마다
변경하고 싶은 LifecycleComponent의
다른 속성이 있을 때 유용할 수 있습니다.

#30
You could then use the ngOnChanges hook to do that,
because that hook gets triggered whenever the input changes,
so you could then calculate
some new Component internal State based on that
and based on the changes information you're getting here,
for example.

ngOnChanges 훅을 사용할 수 있습니다,
입력이 변경될 때마다 이 훅이 트리거되기 때문에,
이를 기반으로,
그리고 여기서 받는 변경 정보를 기반으로
새로운 컴포넌트 내부 상태를
계산할 수 있습니다.

#31
But that's the ngOnChanges hook.
As you see, there also are some other hooks
that are executed in this order.

이것이 ngOnChanges 훅입니다.
보시다시피, 이 순서대로 실행되는
다른 훅들도 있습니다.

#32
And before we now explore in greater depth
what these different hooks are about,
I first of all wanna show you the ngOnDestroy hook in Action,
and also show you which hooks get triggered
if we change the Component without making it disappear.

이제 이러한 다른 훅들이 무엇인지
자세히 살펴보기 전에,
우선 실제로 작동하는 ngOnDestroy 훅을 보여드리고,
컴포넌트를 사라지게 하지 않고 변경할 때
어떤 훅들이 트리거되는지도 보여드리겠습니다.

[이전 내용에 이어서 큰 단위로 번역을 진행하겠습니다]

#33 - #38
But let's start with the disappearing case.
For that, I'll clear the console.
And I'll click
this toggle LifecycleComponent visibility button again.
And that removes the Component from the screen.
And as you can tell,
the ngOnDestroy Lifecycle Hook method was executed.
Because that is a method,
a Lifecycle Hook method you can implement
to do some cleanup work, for example.
Because it will be executed
right before the Component instance
is about to be destroyed.

사라지는 경우부터 시작해보겠습니다.
이를 위해 콘솔을 지우겠습니다.
그리고 이 LifecycleComponent 가시성 전환 버튼을
다시 클릭하겠습니다.
그러면 화면에서 컴포넌트가 제거됩니다.
그리고 보시다시피,
ngOnDestroy 라이프사이클 훅 메서드가 실행되었습니다.
이는 예를 들어 정리 작업을 수행하기 위해
구현할 수 있는 메서드,
즉 라이프사이클 훅 메서드이기 때문입니다.
컴포넌트 인스턴스가
파괴되기 직전에
실행되기 때문입니다.

#39 - #45
For example, because the Component was removed
from the screen because it was rendered conditionally,
for example, as it's the case here.
So that's a great hook for doing cleanup work,
and we'll see it in Action in the main project soon.
Now, if I clear the console again,
and I render the Component again,
I again got all these initial hooks that are executed.
And if I now clear this console
and I change the LifecycleComponent text,
you'll see that we also got some hooks being executed,
but not all the hooks we saw before.

예를 들어, 여기서처럼
조건부로 렌더링되어 화면에서
컴포넌트가 제거되었기 때문입니다.
따라서 이는 정리 작업을 수행하기에 좋은 훅이며,
곧 메인 프로젝트에서 실제로 보게 될 것입니다.
이제 콘솔을 다시 지우고
컴포넌트를 다시 렌더링하면,
다시 이러한 초기 훅들이 모두 실행됩니다.
그리고 이제 이 콘솔을 지우고
LifecycleComponent 텍스트를 변경하면,
일부 훅들이 실행되는 것을 볼 수 있지만,
이전에 보았던 모든 훅이 실행되지는 않습니다.

#46 - #52
For example, ngOnInit or the constructor
are not executing again.
But ngOnChanges executed as a first hook
because the input value,
this text which is output here changed.
And we get that change information,
therefore the current value,
but now also the previous value
which was used before in case we needed that.
And then also these hooks.
And therefore it's of course interesting
to understand what all these different hooks here are about.

예를 들어, ngOnInit이나 constructor는
다시 실행되지 않습니다.
하지만 ngOnChanges가 첫 번째 훅으로 실행되었는데
이는 입력 값,
즉 여기 출력되는 이 텍스트가 변경되었기 때문입니다.
그리고 우리는 그 변경 정보를 얻습니다,
따라서 현재 값과,
이제는 필요한 경우를 위해
이전에 사용된 이전 값도 함께 얻습니다.
그리고 이러한 훅들도 실행됩니다.
그래서 당연히 여기 이 모든 다른 훅들이
무엇인지 이해하는 것이 흥미롭습니다.

#53 - #60
And here it's important to understand that the constructor,
so this constructor method here,
is just the standard class constructor,
and has nothing to do with Angular.
Instead in JavaScript and TypeScript,
you can add such a constructor method
to every class you define.
You don't need Angular for that.
This is a standard JavaScript feature,
and you should indeed not use the constructor
for any complex Component initialization work.

그리고 여기서 이해해야 할 중요한 점은
constructor, 즉 이 constructor 메서드는
단순히 표준 클래스 생성자이며
Angular와는 관련이 없다는 것입니다.
대신 JavaScript와 TypeScript에서는
정의하는 모든 클래스에
이러한 constructor 메서드를 추가할 수 있습니다.
이를 위해 Angular가 필요하지 않습니다.
이는 표준 JavaScript 기능이며,
실제로 복잡한 컴포넌트 초기화 작업에
constructor를 사용해서는 안 됩니다.

[계속 진행하겠습니다...]
